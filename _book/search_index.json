[["index.html", "Divergent Git branches - from problem to solution 1 Preface 1.1 Who is this book for? 1.2 Structure", " Divergent Git branches - from problem to solution Ville Lang√©n 12.01.2025 1 Preface In this e-book, I will demonstrate how the Git divergent branches problem can be easily solved in small Git projects where the goal is to primarily work within a single main branch. 1.1 Who is this book for? This book is aimed at researchers, data scientists, and programmers who use Git in their scientific projects and want to deepen their understanding of branch management. 1.2 Structure The book is divided into three parts: Understanding Git operations and branching (chapters 2, 3, and 4) Three different methods for managing divergent branches (chapters 5, 6, and 7) Summary section - which the busiest readers can jump to directly! üèÉüôÇ In the next chapter, we‚Äôll dive into Git basics and how it works with branching. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["one-or-many-brances.html", "2 One Git Branch or Many? 2.1 Git in Software Development 2.2 Git in Academia 2.3 Summary", " 2 One Git Branch or Many? Image credit: Pexels Git workflows differ significantly between software development and academic research, which stems from the goals of each project type and team structure. In this chapter, we‚Äôll examine these differences and their impact on branch management. 2.1 Git in Software Development In software development (e.g., computer game programming), teams often utilize multiple Git branches simultaneously. A typical workflow includes: A main branch (main or master), which contains the production version. Multiple other branches, where individual features are developed and tested separately. Merges to the main branch are only done when features are complete. This structure enables parallel development, minimizes conflicts, and ensures the main branch remains stable. The flowchart below illustrates this approach: 2.2 Git in Academia In academic research, teams often use just a single Git main branch. Reasons for this: Collaboration usually occurs on one or a few shared files (e.g., an article). Using branches could be complicated in smaller teams or informal environments. The following diagram illustrates this workflow structure: This approach makes work distribution simple but increases the risk of branch divergence if multiple members modify the same file simultaneously. 2.3 Summary The differences in Git workflows between software development and academic projects reflect each field‚Äôs priorities. Software development emphasizes stability and parallel development, while academic projects prioritize simplicity and collaborative work on the main branch. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["no-divergences.html", "3 No Git Branch Problems 3.1 Stable Main Branch 3.2 Summary", " 3 No Git Branch Problems Image credit: Pexels In this chapter, we‚Äôll examine a situation where two or more users work in the main branch without any divergence conflicts between updates. I‚Äôll present a simple workflow where users make their own changes and updates without the situation escalating into branch problems. This is a typical situation when everyone remembers to execute a pull command before making their own modifications, keeping the main branch stable. 3.1 Stable Main Branch Situation: Remote Main (C0) Work begins with the main branch in the remote repository, where the latest state is commit C0. The remote repository is illustrated in the following diagram: User 1: Pull (C0) Pull: User 1 downloads the latest data from the remote repository (C0) to their local repository. User 1: modification and push (C1) Modification: User 1 modifies files and makes commit C1. Push: Changes are updated back to the remote repository. The situation in the remote repository after commit C1: User 2: Pull (C1) Pull: User 2 downloads commit C1 to their local repository. User 2: modification and push (C2) Modification: User 2 modifies files and makes commit C2. Push: Changes are updated back to the remote repository. The situation in the remote repository after commit C2: 3.2 Summary In this simple example, both users worked in the main branch without conflicts. Each step follows logically from the previous one: pull ‚Üí modification ‚Üí commit ‚Üí push. In the next chapter, we‚Äôll examine a situation where both users modify commit C0 simultaneously. This can lead to divergent branches and conflict resolution. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["divergences.html", "4 Branch Divergence 4.1 Origin of Branch Problems 4.2 Summary", " 4 Branch Divergence Image credit: Pexels In the previous chapter, we examined a situation where two users worked in the main branch without problems. In this chapter, we‚Äôll see what happens when two users simultaneously make changes to the same commit state C0 and try to push their own commits to the remote repository. 4.1 Origin of Branch Problems Step 1: User 1 and User 2 execute pull command (C0) Both users start the project from the same initial state. They execute a pull command and update their local repositories to commit state C0. The situation is shown in this diagram: Step 2: User 1‚Äôs modifications are accepted to the remote repository User 1 modifies the file and makes commit C1. User 1 executes a push command, and commit C1 is accepted to the remote repository because it‚Äôs based directly on state C0. Step 3: User 2‚Äôs modifications are not accepted to the remote repository User 2 modifies another part of the file and makes commit C2. User 2 tries to execute a push command, but Git prevents this because the main branch in the remote repository has advanced to commit state C1. User 2‚Äôs local commit C2 is now in conflict with the remote repository state. 4.2 Summary When two users try to make changes simultaneously and push them to the remote repository, branch divergence occurs. This means there is a conflict between the remote repository and local branches that requires additional actions from the user (such as merging or rebasing) to resolve the problem. In the next chapter, we‚Äôll discuss how these conflicts can be resolved in different ways. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["method-one.html", "5 Fix Method 1: merge function 5.1 Pull without merge permission 5.2 Giving merge permission 5.3 Pull with merge permission 5.4 Binary files 5.5 Summary", " 5 Fix Method 1: merge function Image credit: Pexels In the previous chapter, we examined a situation where two users simultaneously made changes to the same commit state C0 and tried to push their own commits to the remote repository. In this chapter, we‚Äôll see what happens when a user configures Git settings so that the pull command automatically attempts to merge changes. We‚Äôll examine the progression of the situation especially from User 2‚Äôs perspective. 5.1 Pull without merge permission Step 1: User 1 and User 2 execute pull command (C0) Both users start the project from the same initial state. They execute a pull command and update their local repositories to commit state C0. After this, they begin working on the file test.R. At point C0, it looks like this for all users: Figure. Initial state at commit point C0. Step 2: Users 1 and 2 modify the file independently User 1 has modified the file and already pushed it to the remote repository. User 2 has also modified the file but hasn‚Äôt pushed it to the remote repository yet. Figure. User 1‚Äôs changes already in remote repository (left image), User 2‚Äôs changes not yet pushed (right). The users‚Äô changes clearly differ from each other. Step 3: User 2 tries to push their modifications to the remote repository User 2 first tries to execute a pull command, but this fails: Video Video. First - and failed - pull attempt. User 2 tries to execute commit + push command, but this also fails: Video Video. Commit + push also fails. User 2 makes another pull command and receives the following error message with instructions: Video Video. New - failed - pull attempt. User 2 copies the following command from Git‚Äôs instructions to the clipboard: git config pull.rebase false Video. Command to be copied to clipboard from pull attempt. 5.2 Giving merge permission Before User 2 makes a third pull attempt, they run the command in Terminal git config pull.rebase false to give Git permission to attempt merge operation when pulling new changes from the remote repository. Running the command in Terminal happens as follows: Video Video. Running the command git config pull.rebase false in Terminal. 5.3 Pull with merge permission Now User 2 can successfully execute a pull command, which creates a new merge commit. However, it produces a warning that instructs to verify that the merge was successful: Video Video. Third pull attempt succeeds. Next, User 2 needs to verify by editing the test file test.r that the merge was successful. Video Video. File test.R must be manually edited to fix after the merge operation. After this, commit + push operations go through without problems: Video Video. Commit + push operations go through to the remote repository. Now the file test.R appears in User 2‚Äôs updated form in GitHub: Video Video. The merged file now appears in the remote repository on GitHub. 5.4 Binary files Binary files are files that contain information in a form that cannot be directly read or edited with a text editor. Examples of binary files include Word documents (.docx) and bitmap images (e.g., .png). These files cannot be merged with Git‚Äôs merge operation because their content cannot be interpreted as simple text, and even small changes in the file can cause large differences in the binary structure. Even if you set Git to use git config pull.rebase false to ensure simpler pulling, it doesn‚Äôt help resolve merging binary files. When two users make changes to the same binary file in different commit states, a situation arises that requires more robust solutions. 5.4.1 Example with .docx Step 1: Remote repository state (C0) All users start from a situation where test.docx is in commit state C0 and looks like this: Step 2. User 1 and User 2 make their own modifications to the same Word file: Figure. User 1‚Äôs modifications. Figure. User 2‚Äôs modifications. Step 3: User 1‚Äôs changes are accepted User 1 manages to make commit C1 and push command after their modifications before User 2, and commit C1 is accepted to the remote repository because it‚Äôs based directly on commit state C0. Step 4: User 2‚Äôs changes are rejected User 2 tries to make commit C2 after modifying the test.docx file. However, Git prevents the push command because the remote repository has moved to commit state C1. This causes a conflict. User 2 cannot execute commit, push, or pull commands. Figure. User 2 gets stuck with Git. Commit state C1 cannot be pulled, and commit state C2 cannot be pushed on top of commit state C1. Even if User 2 gives the command git config pull.rebase false and tries to pull after that, Git cannot merge the two different versions of the test.docx file because it‚Äôs a binary file. 5.5 Summary git config pull.rebase false is actually best in situations where users haven‚Äôt really modified the same file simultaneously but have forgotten to execute a pull command before making modifications to the repository. In such cases, resolving conflicts between commit points is relatively easy for Git. git config pull.rebase false is not, however, a very effective solution for situations where users have truly modified the same file simultaneously. In such cases, the resulting conflicts usually require at least manual merge editing. For binary files, merging modifications with git config pull.rebase false doesn‚Äôt work at all. Because Git cannot merge the contents of binary files, all such conflict situations must be resolved by other means, such as choosing one version of the file. We‚Äôll discuss the latter in the next chapter. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["method-two.html", "6 Fix Method 2: git reset 6.1 Initial Situation 6.2 Reset Command 6.3 Summary", " 6 Fix Method 2: git reset Image credit: Pexels When a user tries to make changes but the main branch in the remote repository has advanced simultaneously, Git branch divergence can prevent work from progressing smoothly. One way to resolve such situations is to use the reset method. In this chapter, we‚Äôll present an example of this. 6.1 Initial Situation The initial situation is similar to what was described in section 5.1. Users 1 and 2 have this time modified the file test2.R. User 1 has already performed commit and push operations, so the main branch in the remote repository has already advanced to commit state C1. (See image below.) Figure. Versions of file test2.R in the remote repository (left) and on User 2‚Äôs computer (right) differ from each other. When User 2 now tries to execute a pull command, Git prevents this because the local branch is ahead of commit point C0. The situation is shown in the following diagram: 6.2 Reset Command User 2 can resolve the situation with the following steps: First backup the problematic file User 2 copies the file test.R to their desktop or other backup folder. This prevents the file from being lost when the Git state is updated. Below is a video of this. Note! If the file being moved to the desktop is open in RStudio, it will warn about the file being moved: Video Video. The problematic file test2.R is backed up to the desktop. Reset the timepoint to the latest main branch timepoint in the remote repository The user executes the following commands to return to the remote repository‚Äôs latest state (C1): git fetch git reset --hard origin/main These commands ensure that: The local repository matches the latest state of the remote repository git fetch downloads the latest changes from the remote repository without changing local files git reset --hard origin/main returns the local branch and workspace exactly to the remote repository‚Äôs state. Video Video. Reset command. Examining the test2.R file By opening the test2.R file, User 2 can see that the file has returned to User 1‚Äôs modified commit state C1: Video Video. Examining the test2.R file. Restoring User 2‚Äôs modified test2.R file User 2‚Äôs modified test2.R file can now be restored from the desktop to the local Git repository. At the same time, it is renamed to test2 copy.R: Video Video. Restoring file test2.R from desktop. Examining files test2.R and test2 copy.R User 2 can now examine the differences between these files in RStudio: Video Video. Examining files test2.R and test2 copy.R in RStudio. Commit and push operation to remote repository User 2 can now perform commit and push operations for the file test2 copy.R: Video Video. Successful commit and push operation. Examining the remote repository in GitHub User 2 can now verify that their modified file test2 copy.R appears in the remote repository: Video Video. The file test2 copy.R now appears in the remote repository. 6.3 Summary The reset method offers a straightforward and effective way to resolve situations where the local branch and remote repository have diverged. The most important steps include backing up the problematic file, using the reset command to return to the remote repository state, and finally restoring the file with a new name. This way, users can continue working without losing data, and commit and push operations work again. The reset method helps avoid resolving more complex conflicts while preserving both your own work and the integrity of the team‚Äôs main branch. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["method-three.html", "7 Fix Method 3: cloning 7.1 Steps 7.2 Summary", " 7 Fix Method 3: cloning Image credit: Pexels If the previous fix methods don‚Äôt work or aren‚Äôt suitable, you can always start fresh by cloning a new version from the remote repository. This not only brings a clean version of your project but also eliminates any problems and conflicts that existed with the local Git repository. 7.1 Steps The first step is to go to the GitHub repository you want to clone. Navigate to the repository page on GitHub and click the ‚ÄúCode‚Äù button. Then select ‚ÄúHTTPS‚Äù and copy the URL to your clipboard. Video Video. Copying the remote repository URL to clipboard in GitHub. Next, in RStudio, select ‚ÄúNew Project‚Äù ‚Üí ‚ÄúVersion Control‚Äù ‚Üí ‚ÄúGit‚Äù. Paste the URL you just copied into the ‚ÄúRepository URL‚Äù field, press your computer‚Äôs Tab key, and modify the folder name as desired. For example, you can add a ‚Äú2‚Äù to the end of the original name to distinguish it from the problematic repository. Video Video. Cloning the remote repository in RStudio. 7.2 Summary Cloning a new repository is a reliable way to resolve issues related to conflicts between local and remote versions. This method ensures a clean starting point, allowing you to continue working on the project without previous technical obstacles. It‚Äôs particularly suitable for situations where local repository problems are difficult to fix and other methods, such as git reset, aren‚Äôt appropriate to use. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["fine-tuning-git-diff.html", "8 Fine-tuning: git diff", " 8 Fine-tuning: git diff Image credit: Pexels Let‚Äôs imagine a situation where the file ‚Äòtest.R‚Äô is identical in both the remote repository and local repository, but there are differences between them in the file ‚Äòtest2.R‚Äô. This kind of scenario was described earlier in section 6.1. If conflicts occur between Git branches during commit and push operations, the Git user can investigate the situation further. Differences between the local Git branch and remote repository can be examined in more detail using the following commands: git fetch git diff main origin/main Command explanation: The first command git fetch ensures that Git updates information about the remote repository‚Äôs state without merging it with the local version. The information is stored locally in Git‚Äôs hidden .git/ directory for examination purposes only. The second command git diff main origin/main shows detailed differences between the local main branch (main) and the remote repository‚Äôs main branch (origin/main). Video Video. Examining differences between local and remote repository. This method is particularly useful when the user isn‚Äôt sure which files are causing problems or what changes have been made. This way, users can examine changes at the file level and make necessary corrections. This kind of examination isn‚Äôt always necessary. If users already know which files or changes are problematic, this step can be skipped. For example, in simple projects where the source of conflict is clear, such as a single file, this detailed examination isn‚Äôt needed. However, in more complex situations or large projects, this method can save time and help detect hidden problems. Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["final-summary.html", "9 Summary", " 9 Summary Image credit: Pexels There are several methods for resolving Git branch conflicts, and their application depends on the complexity of the situation: Sometimes a simple command git config pull.rebase false and a new pull-commit-push sequence is sufficient to solve the problem. The git config pull.rebase false command is run in Terminal: git config pull.rebase false In more complex situations, the user might need to copy new local modifications to the desktop and perform a hard reset, which returns the local directory to match the remote repository‚Äôs state. The commands to be executed in Terminal are: git fetch git reset --hard origin/main If nothing else helps, creating a new clone from the remote repository is always a sure and final solution that removes all conflicts. Video Video With these methods, you can regain control of your Git project. Thank you for reading this guide on solving Git branch problems. Git can sometimes feel challenging, but as shown in this guide, every problem has a solution. Good luck with your Git projects! Divergent Git branches - from problem to solution ¬© 2025 by Ville Lang√©n is licensed under the CC BY-SA 4.0. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
